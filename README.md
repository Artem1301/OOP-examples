# OOP-examples
@rD3, [17.06.2024 12:26]
KISS (Keep It Simple, Stupid)
Принцип: Дизайн повинен бути максимально простим і зрозумілим. Складність може ускладнити підтримку та розуміння коду.

Приклад: У проекті, де потрібно зберігати конфігурацію, замість складних структур і методів для роботи з різними форматами, використовується простий JSON-файл.

@rD3, [17.06.2024 12:26]
Мінімалізм
Принцип: Дизайн повинен бути спрощений до мінімуму, щоб забезпечити необхідний функціонал без зайвих елементів.

Приклад: У додатку для роботи з базами даних створено тільки ті функції, які необхідні для виконання основних операцій (CRUD).

@rD3, [17.06.2024 12:26]
Coupling and Cohesion (Зв'язність і когезія)
Принцип: Зв'язність (coupling) повинна бути мінімальною, а когезія (cohesion) — максимальною.

Приклад: Клас для обробки даних не має залежностей від класу, що виконує операції з API, що дозволяє легко змінювати кожен клас без впливу на інший.

@rD3, [17.06.2024 12:26]
Принципи можливості розвитку (Extensibility) та Pay as You Go
Принцип можливості розвитку: Система повинна бути спроектована так, щоб її можна було легко розширювати без значних змін в існуючому коді.

Pay as You Go: Платити за функціональність потрібно лише тоді, коли вона дійсно потрібна, а не заздалегідь.

Приклад: Додавання нових видів графіків у додаток для побудови діаграм можна реалізувати шляхом додавання нових класів без змін у базовому коді.

@rD3, [17.06.2024 12:26]
Law of Demeter (Принцип Деметри)
Принцип: Об'єкт повинен спілкуватися тільки зі своїми найближчими "друзями" і не заглиблюватися в структуру інших об'єктів.

Приклад: Клас Order взаємодіє тільки з класом Customer без доступу до деталей адреси клієнта.

@rD3, [17.06.2024 12:27]
Принцип YAGNI (You Aren’t Gonna Need It)
Принцип: Не реалізовуйте функціональність, поки вона дійсно не знадобиться.

Приклад: У проекті планувалося додати підтримку кількох мов, але оскільки поки використовується тільки англійська, підтримку інших мов не було реалізовано.

@rD3, [17.06.2024 12:27]
Principle of Least Astonishment (Принцип найменшого здивування)
Принцип: Інтерфейси та функціональність повинні вести себе так, як очікує користувач.

Приклад: Метод для видалення елементу зі списку працює аналогічно методу видалення у вбудованих структурах Python.

@rD3, [17.06.2024 12:27]
Принципи DRY (Don’t Repeat Yourself) та WET (Write Everything Twice)
DRY: Уникайте повторення коду, винесіть загальні частини в окремі модулі чи функції.

WET: Повторення коду може бути корисним для уникнення передчасної оптимізації та збереження простоти коду.

Приклад (DRY): Використання функції для обробки даних замість дублювання коду.

@rD3, [17.06.2024 12:28]
Принцип SRP (Single Responsibility Principle)
Принцип: Кожен клас повинен мати лише одну причину для зміни, тобто виконувати одну роль.

Приклад: Розділення відповідальності за обробку замовлень та управління користувачами на різні класи.

@rD3, [17.06.2024 12:28]
Принципи абстракції та Information Hiding
Абстракція: Виділення суттєвих деталей та ігнорування несуттєвих, щоб спростити модель системи.

Information Hiding: Приховування деталей реалізації, надаючи тільки необхідний інтерфейс.

Приклад: Інтерфейс Vehicle приховує деталі реалізації конкретних транспортних засобів.

@rD3, [17.06.2024 12:28]
Принцип OCP (Open/Closed Principle)
Принцип: Програмні модулі повинні бути відкритими для розширення, але закритими для змін.

Приклад: Додавання нових типів платіжних методів без зміни існуючого коду.

@rD3, [17.06.2024 12:28]
Принципи SoC (Separation of Concerns) та Orthogonality
SoC: Поділ системи на частини, які відповідають за різні аспекти функціональності.

Orthogonality: Компоненти системи повинні бути незалежними один від одного.

Приклад: Розділення логіки збереження даних та їх валідації на окремі класи.

@rD3, [17.06.2024 12:28]
Принципи Reuse (Перевикористання) та ISP (Interface Segregation Principle)
Reuse: Використання наявних компонентів або коду для вирішення нових задач.

ISP: Інтерфейси повинні бути вузькоспеціалізованими, щоб клієнти залежали тільки від тих методів, які їм потрібні.

Приклад (ISP): Розділення великого інтерфейсу на спеціалізовані.

@rD3, [17.06.2024 12:28]
Принципи підтримки, Scout Rule та DIP (Dependency Inversion Principle)
Підтримка: Код повинен бути зрозумілим і легко підтримуваним.

Scout Rule: Залиште код у кращому стані, ніж він був до ваших змін.

DIP: Модулі вищого рівня не повинні залежати від модулів нижчого рівня. Замість цього, обидва типи модулів повинні залежати від абстракцій.

Приклад (DIP): Залежність на абстракції для зберігання даних.

@rD3, [17.06.2024 12:28]
Rule of Least Power та Law of Demeter
Rule of Least Power: Використовуйте найменш потужні засоби, які можуть виконати задачу, щоб зменшити складність і підвищити зрозумілість.

Law of Demeter: Об'єкт повинен спілкуватися тільки зі своїми найближчими "друзями".

Приклад: Використання простих функцій для виконання завдань, замість складних структур.

@rD3, [17.06.2024 12:28]
ETC (Ease of Change) та Principle of Least Astonishment
ETC: Програми повинні легко змінюватися при зміні вимог.

Principle of Least Astonishment: Програми повинні вести себе так, як очікує користувач.

Приклад: Чітко визначені інтерфейси, які легко змінити при додаванні нових функцій.

@rD3, [17.06.2024 12:28]
Pareto Principle (Принцип Парето)
Принцип: 80% результатів досягаються за рахунок 20% зусиль.

Приклад: Зосередження на ключових функціях додатка, які забезпечують основний користувацький досвід.

@rD3, [17.06.2024 12:28]
Rule of Three та OdryCP (Once, Default, Reuse, You Can Pay)
Rule of Three: Вважайте, що код, який ви дублюєте більше ніж двічі, повинен бути спрощений або об'єднаний.

OdryCP: Вивчення переваг повторного використання коду після досягнення мінімальної функціональності.

Приклад: Створення функції для обробки даних після того, як її код використовувався тричі в різних місцях.

@rD3, [17.06.2024 12:29]
Принципи декомпозиції та Cross-Cutting Concerns
Декомпозиція: Поділ великих задач на менші частини, які легше розробляти та підтримувати.

Cross-Cutting Concerns: Задачі, що стосуються кількох частин системи, такі як логування та безпека.

Приклад: Виділення модулю для логування, який використовується у всіх частинах додатку.

@rD3, [17.06.2024 12:29]
Orthogonality та DIP (Dependency Inversion Principle)
Orthogonality: Компоненти повинні бути незалежними один від одного.

DIP: Модулі вищого рівня не повинні залежати від модулів нижчого рівня.

Приклад: Використання інтерфейсу для взаємодії між модулями, що дозволяє легко змінювати реалізацію.

@rD3, [17.06.2024 12:29]
Chesterton’s Fence (Забор Честертон)
Принцип: Не змінюйте існуючу систему, не розуміючи, чому вона була створена саме так.

Приклад: Перш ніж видалити або змінити частину коду, вивчіть її історію та призначення.

Перфекціонізм
Принцип: Перфекціонізм може призвести до надмірних витрат часу і ресурсів. Важливо знайти баланс між якістю і ефективністю.

Single Source of Truth (SSOT)
Принцип: Інформація повинна зберігатися лише в одному місці, щоб уникнути її дублювання та розбіжностей.

Приклад: Використання централізованої бази даних для зберігання даних клієнтів.

Law of Leaky Abstractions
Принцип: Навіть абстракції, які приховують складність, іноді пропускають деталі реалізації, що може призвести до проблем.

Приклад: Використання ORM не завжди приховує деталі SQL-запитів.

Occam’s Razor (Бритва Оккама)
Принцип: Серед кількох можливих рішень, найкращим є найпростше.

MVP (Minimum Viable Product)
Принцип: Спочатку створіть мінімально життєздатний продукт, щоб отримати зворотній зв’язок від користувачів.

Приклад: Реалізація лише основних функцій у додатку для управління завданнями, щоб швидко отримати відгуки користувачів.

Hyrum's Law
Принцип: З часом користувачі будуть використовувати всі можливості вашого програмного забезпечення, навіть ті, які ви не передбачили.

Zero-Cost Abstractions
Принцип: Абстракції не повинні впливати на продуктивність, вони мають бути такими ж ефективними, як і низькорівневий код.
