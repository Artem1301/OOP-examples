# OOP-examples
KISS (Keep It Simple, Stupid)
Принцип: Дизайн повинен бути максимально простим і зрозумілим. Складність може ускладнити підтримку та розуміння коду.

Приклад: У проекті, де потрібно зберігати конфігурацію, замість складних структур і методів для роботи з різними форматами, використовується простий JSON-файл.

Мінімалізм
Принцип: Дизайн повинен бути спрощений до мінімуму, щоб забезпечити необхідний функціонал без зайвих елементів.

Приклад: У додатку для роботи з базами даних створено тільки ті функції, які необхідні для виконання основних операцій (CRUD).

Coupling and Cohesion (Зв'язність і когезія)
Принцип: Зв'язність (coupling) повинна бути мінімальною, а когезія (cohesion) — максимальною.

Приклад: Клас для обробки даних не має залежностей від класу, що виконує операції з API, що дозволяє легко змінювати кожен клас без впливу на інший.

Принципи можливості розвитку (Extensibility) та Pay as You Go
Принцип можливості розвитку: Система повинна бути спроектована так, щоб її можна було легко розширювати без значних змін в існуючому коді.

Pay as You Go: Платити за функціональність потрібно лише тоді, коли вона дійсно потрібна, а не заздалегідь.

Приклад: Додавання нових видів графіків у додаток для побудови діаграм можна реалізувати шляхом додавання нових класів без змін у базовому коді.

Law of Demeter (Принцип Деметри)
Принцип: Об'єкт повинен спілкуватися тільки зі своїми найближчими "друзями" і не заглиблюватися в структуру інших об'єктів.

Приклад: Клас Order взаємодіє тільки з класом Customer без доступу до деталей адреси клієнта.

Принцип YAGNI (You Aren’t Gonna Need It)
Принцип: Не реалізовуйте функціональність, поки вона дійсно не знадобиться.

Приклад: У проекті планувалося додати підтримку кількох мов, але оскільки поки використовується тільки англійська, підтримку інших мов не було реалізовано.

Principle of Least Astonishment (Принцип найменшого здивування)
Принцип: Інтерфейси та функціональність повинні вести себе так, як очікує користувач.

Приклад: Метод для видалення елементу зі списку працює аналогічно методу видалення у вбудованих структурах Python.

Принципи DRY (Don’t Repeat Yourself) та WET (Write Everything Twice)
DRY: Уникайте повторення коду, винесіть загальні частини в окремі модулі чи функції.

WET: Повторення коду може бути корисним для уникнення передчасної оптимізації та збереження простоти коду.

Приклад (DRY): Використання функції для обробки даних замість дублювання коду.

Принцип SRP (Single Responsibility Principle)
Принцип: Кожен клас повинен мати лише одну причину для зміни, тобто виконувати одну роль.

Приклад: Розділення відповідальності за обробку замовлень та управління користувачами на різні класи.

Принципи абстракції та Information Hiding
Абстракція: Виділення суттєвих деталей та ігнорування несуттєвих, щоб спростити модель системи.

Information Hiding: Приховування деталей реалізації, надаючи тільки необхідний інтерфейс.

Приклад: Інтерфейс Vehicle приховує деталі реалізації конкретних транспортних засобів.

Принцип OCP (Open/Closed Principle)
Принцип: Програмні модулі повинні бути відкритими для розширення, але закритими для змін.

Приклад: Додавання нових типів платіжних методів без зміни існуючого коду.

Принципи SoC (Separation of Concerns) та Orthogonality
SoC: Поділ системи на частини, які відповідають за різні аспекти функціональності.

Orthogonality: Компоненти системи повинні бути незалежними один від одного.

Приклад: Розділення логіки збереження даних та їх валідації на окремі класи.

Принципи Reuse (Перевикористання) та ISP (Interface Segregation Principle)
Reuse: Використання наявних компонентів або коду для вирішення нових задач.

ISP: Інтерфейси повинні бути вузькоспеціалізованими, щоб клієнти залежали тільки від тих методів, які їм потрібні.

Приклад (ISP): Розділення великого інтерфейсу на спеціалізовані.

Принципи підтримки, Scout Rule та DIP (Dependency Inversion Principle)
Підтримка: Код повинен бути зрозумілим і легко підтримуваним.

Scout Rule: Залиште код у кращому стані, ніж він був до ваших змін.

DIP: Модулі вищого рівня не повинні залежати від модулів нижчого рівня. Замість цього, обидва типи модулів повинні залежати від абстракцій.

Приклад (DIP): Залежність на абстракції для зберігання даних.

Rule of Least Power та Law of Demeter
Rule of Least Power: Використовуйте найменш потужні засоби, які можуть виконати задачу, щоб зменшити складність і підвищити зрозумілість.

Law of Demeter: Об'єкт повинен спілкуватися тільки зі своїми найближчими "друзями".

Приклад: Використання простих функцій для виконання завдань, замість складних структур.

ETC (Ease of Change) та Principle of Least Astonishment
ETC: Програми повинні легко змінюватися при зміні вимог.

Principle of Least Astonishment: Програми повинні вести себе так, як очікує користувач.

Приклад: Чітко визначені інтерфейси, які легко змінити при додаванні нових функцій.

Pareto Principle (Принцип Парето)
Принцип: 80% результатів досягаються за рахунок 20% зусиль.

Приклад: Зосередження на ключових функціях додатка, які забезпечують основний користувацький досвід.

Rule of Three та OdryCP (Once, Default, Reuse, You Can Pay)
Rule of Three: Вважайте, що код, який ви дублюєте більше ніж двічі, повинен бути спрощений або об'єднаний.

OdryCP: Вивчення переваг повторного використання коду після досягнення мінімальної функціональності.

Приклад: Створення функції для обробки даних після того, як її код використовувався тричі в різних місцях.

Принципи декомпозиції та Cross-Cutting Concerns
Декомпозиція: Поділ великих задач на менші частини, які легше розробляти та підтримувати.

Cross-Cutting Concerns: Задачі, що стосуються кількох частин системи, такі як логування та безпека.

Приклад: Виділення модулю для логування, який використовується у всіх частинах додатку.

Orthogonality та DIP (Dependency Inversion Principle)
Orthogonality: Компоненти повинні бути незалежними один від одного.

DIP: Модулі вищого рівня не повинні залежати від модулів нижчого рівня.

Приклад: Використання інтерфейсу для взаємодії між модулями, що дозволяє легко змінювати реалізацію.

Chesterton’s Fence (Забор Честертон)
Принцип: Не змінюйте існуючу систему, не розуміючи, чому вона була створена саме так.

Приклад: Перш ніж видалити або змінити частину коду, вивчіть її історію та призначення.

Перфекціонізм
Принцип: Перфекціонізм може призвести до надмірних витрат часу і ресурсів. Важливо знайти баланс між якістю і ефективністю.

Single Source of Truth (SSOT)
Принцип: Інформація повинна зберігатися лише в одному місці, щоб уникнути її дублювання та розбіжностей.

Приклад: Використання централізованої бази даних для зберігання даних клієнтів.

Law of Leaky Abstractions
Принцип: Навіть абстракції, які приховують складність, іноді пропускають деталі реалізації, що може призвести до проблем.

Приклад: Використання ORM не завжди приховує деталі SQL-запитів.

Occam’s Razor (Бритва Оккама)
Принцип: Серед кількох можливих рішень, найкращим є найпростше.

MVP (Minimum Viable Product)
Принцип: Спочатку створіть мінімально життєздатний продукт, щоб отримати зворотній зв’язок від користувачів.

Приклад: Реалізація лише основних функцій у додатку для управління завданнями, щоб швидко отримати відгуки користувачів.

Hyrum's Law
Принцип: З часом користувачі будуть використовувати всі можливості вашого програмного забезпечення, навіть ті, які ви не передбачили.

Zero-Cost Abstractions
Принцип: Абстракції не повинні впливати на продуктивність, вони мають бути такими ж ефективними, як і низькорівневий код.




Паттерны проектирования
1. Общее
Паттерн или шаблон проектирования - повторимая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста.
2. Creational Patterns
Abstract Factory (Абстрактная фабрика) - предоставляет интерфейс для создания групп связанных или зависимых объектов, не указывая их конкретный класс.

Factory Method (Фабричный метод) - определяет интерфейс для создания объекта, но позволяет подклассам решать, какой класс инстанцировать. Позволяет делегировать создание объекта подклассам.

Builder (Строитель) - разделяет создание сложного объекта и инициализацию его состояния так, что одинаковый процесс построения может создать объекты с разным состоянием.

Prototype (Прототип) - определяет несколько видов объектов, чтобы при создании использовать объект-прототип и создает новые объекты, копируя прототип.

Примером реализации в Java данного паттерна является метод java.util.Object.clone().
Singleton (Одиночка) - гарантирует, что класс имеет только один экземпляр и предоставляет глобальную точку доступа к нему.

3. Structural Patterns
Adapter (Адаптер) - конвертирует интерфейс класса в другой интерфейс, ожидаемый клиентом. Позволяет классам с разными интерфейсами работать вместе.

Proxy (Прокси) - предоставляет замену другого объекта для контроля доступа к нему.

Bridge (Мост) - разделяет абстракцию и реализацию так, чтобы они могли изменяться независимо.

Composite (Компоновщик) - компонует объекты в дреновидную структуру, представляя их в виде иерархии. Позволяет клиенту одинакового обращаться как к отдельному объекту, так и к целому поддереву.

Decorator (Декоратор) - динамически предоставляет объекту дополнительные возможности. Представляет собой гибкую альтернативу наследованию для расширения функциональности.

Facade (Фасад) - предоставляет единый интерфейс к группе интерфейсов подсистемы. Определяет высокоуровневый интерфейс, делая подсистему проще для использования.

Flyweight (Приспособленец, Легковесная) - благодаря совместному использованию, поддерживает эффективную работу с большим количеством объектов. Его суть заключается в том, что тяжеловесный объект, представляющий себя как уникальный экземпляр в разных местах программы, по факту не является таковым.

Примером является старая реализация java.lang.String, где тяжеловсным объектом является массив charов, а все условные копии данной строки ссылаются на него-же. Таким образом методы вроде java.lang.String.substring() работали быстро, так как достаточно было только передвинуть указатели и отображать кусок от всей строки. От такой реализации отказались, так как она могла привести к утечке памяти.
4. Behavioral Patterns
Memento (Хранитель) - не нарушая инкапсуляцию, определяет и сохраняет внутреннее состояние объекта и позволяет позже восстановить объект в этом состоянии.

Chain of responsibility (Цепочка обязанностей) - избегает связывания отправителя запроса с его получателем, давая возможность обработать запрос более чем одному объекту. Связывает объекты-получатели и передает запрос по цепочке, пока объект не обработает его.

Observer (Наблюдатель) - определяет зависимость "один ко многим" между объектами так, что когда один объект меняет свое состояние, все зависимые объекты оповещаются и обновляются автоматически.

Command (Команда) - инкапсулирует запрос в виде объекта, позволяя передавать их клиентам в качестве параметров, ставить в очередь, логировать, а также поддерживает отмену операций.

State (Состояние) - позволяет объекту менять свое поведение в зависимости от внутреннего состояния.

Interpreter (Интерпретатор) - получая формальный язык, определяет представление его грамматики и интерпретатор, использующий это представление для обработки выражений языка.

Strategy (Стратегия) - определяет группу алгоритмов, инкапсулирует их и делает взаимозаменяемыми. Позволяет изменять алгоритм независимо от клиентов, его использующих.

Iterator (Итератор) - предоставляет способ последовательного доступа к элементам множества, независимо от его внутренного устройства.

Template method (Шаблонный метод) - определяет алгоритм, некоторые этапы которого делегируются подклассам. Позволяет подклассам переопределить эти этапы, не меняя структуру алгоритма.

Mediator (Посредник) - определяет объект, инкапсулирующий способ взаимодействия объектов. Обеспечивает слабую свзяь, избавляя объекты от необходимости прямо ссылаться друг на друга и дает возможность независимо изменять их взаимодействие.

Visitor (Посетитель) - представляет собой операцию, которая будет выполнена над объектами группы классов. Дает возможность определить новую операцию без изменения кода классов, над которыми эта операция проводится.

Примером этого паттерна является работа javac компилятора.
5. MVC
MVC (Model-View-Controller) - схема использования нескольких шаблонов проектирования, с помощью которых модель приложения, пользовательский интерфейс и взаимодействие с пользователем разделены на три отдельных компонента таким образом, чтобы модификация одного из компонентов оказывала минимальное воздействие на остальные.
6. MVP
MVP (Model-View-Presenter) - шаблон проектирования, производный от MVC, который используется в основном для построения пользовательского интерфейса. Элемент Presenter в данном шаблоне берёт на себя функциональность посредника (аналогично контроллеру в MVC) и отвечает за управление событиями пользовательского интерфейса так же, как в других шаблонах обычно отвечает представление.
7. MVVM
MVVM (Model-View-ViewModel) - шаблон проектирования, производный от MVP, который используется для разделения модели и её представления, что необходимо для изменения их отдельно друг от друга. Например, разработчик задает логику работы с данными, а дизайнер соответственно работает с пользовательским интерфейсом.



